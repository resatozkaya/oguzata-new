import {
  require_dayjs_min
} from "./chunk-7RXIZQGQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/dayjs/plugin/customParseFormat.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    }(exports, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var f = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3) return 0;
          if ("Z" === e3) return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], u = function(e2) {
        var t2 = s[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, d = function(e2, t2) {
        var n2, r2 = s.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1) if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
        } else n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, c = { A: [o, function(e2) {
        this.afternoon = d(e2, false);
      }], a: [o, function(e2) {
        this.afternoon = d(e2, true);
      }], Q: [n, function(e2) {
        this.month = 3 * (e2 - 1) + 1;
      }], S: [n, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [r, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r, f("day")], Do: [o, function(e2) {
        var t2 = s.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2) for (var r2 = 1; r2 <= 31; r2 += 1) t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], w: [i, f("week")], ww: [r, f("week")], M: [i, f("month")], MM: [r, f("month")], MMM: [o, function(e2) {
        var t2 = u("months"), n2 = (u("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1) throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [o, function(e2) {
        var t2 = u("months").indexOf(e2) + 1;
        if (t2 < 1) throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, f("year")], YY: [r, function(e2) {
        this.year = a(e2);
      }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
      function l(n2) {
        var r2, i2;
        r2 = n2, i2 = s && s.formats;
        for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o3 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a2 = o2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = o2[f2], u2 = c[h2], d2 = u2 && u2[0], l2 = u2 && u2[1];
          o2[f2] = l2 ? { regex: d2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = o2[n3];
            if ("string" == typeof i3) r3 += i3.length;
            else {
              var s2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, o2 = e3.args;
          this.$u = r3;
          var a2 = o2[1];
          if ("string" == typeof a2) {
            var f2 = true === o2[2], h2 = true === o2[3], u2 = f2 || h2, d2 = o2[2];
            h2 && (d2 = o2[2]), s = this.$locale(), !f2 && d2 && (s = n2.Ls[d2]), this.$d = function(e4, t4, n3, r4) {
              try {
                if (["x", "X"].indexOf(t4) > -1) return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var i3 = l(t4)(e4), o3 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
                o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r4(D).week(m2).toDate()), D);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a2, r3, n2), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array) for (var c2 = a2.length, m = 1; m <= c2; m += 1) {
            o2[1] = a2[m - 1];
            var M = n2.apply(this, o2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else i2.call(this, e3);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/localizedFormat.js
var require_localizedFormat = __commonJS({
  "node_modules/dayjs/plugin/localizedFormat.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_localizedFormat = t();
    }(exports, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(t, o, n) {
        var r = o.prototype, i = r.format;
        n.en.formats = e, r.format = function(t2) {
          void 0 === t2 && (t2 = "YYYY-MM-DDTHH:mm:ssZ");
          var o2 = this.$locale().formats, n2 = function(t3, o3) {
            return t3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t4, n3, r2) {
              var i2 = r2 && r2.toUpperCase();
              return n3 || o3[r2] || e[r2] || o3[i2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t5, o4) {
                return t5 || o4.slice(1);
              });
            });
          }(t2, void 0 === o2 ? {} : o2);
          return i.call(this, n2);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/isBetween.js
var require_isBetween = __commonJS({
  "node_modules/dayjs/plugin/isBetween.js"(exports, module) {
    !function(e, i) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isBetween = i();
    }(exports, function() {
      "use strict";
      return function(e, i, t) {
        i.prototype.isBetween = function(e2, i2, s, f) {
          var n = t(e2), o = t(i2), r = "(" === (f = f || "()")[0], u = ")" === f[1];
          return (r ? this.isAfter(n, s) : !this.isBefore(n, s)) && (u ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r ? this.isBefore(n, s) : !this.isAfter(n, s)) && (u ? this.isAfter(o, s) : !this.isBefore(o, s));
        };
      };
    });
  }
});

// node_modules/@date-io/dayjs/build/index.esm.js
var import_dayjs = __toESM(require_dayjs_min());
var import_customParseFormat = __toESM(require_customParseFormat());
var import_localizedFormat = __toESM(require_localizedFormat());
var import_isBetween = __toESM(require_isBetween());
import_dayjs.default.extend(import_customParseFormat.default);
import_dayjs.default.extend(import_localizedFormat.default);
import_dayjs.default.extend(import_isBetween.default);
var withLocale = (dayjs, locale) => !locale ? dayjs : (...args) => dayjs(...args).locale(locale);
var defaultFormats = {
  normalDateWithWeekday: "ddd, MMM D",
  normalDate: "D MMMM",
  shortDate: "MMM D",
  monthAndDate: "MMMM D",
  dayOfMonth: "D",
  year: "YYYY",
  month: "MMMM",
  monthShort: "MMM",
  monthAndYear: "MMMM YYYY",
  weekday: "dddd",
  weekdayShort: "ddd",
  minutes: "mm",
  hours12h: "hh",
  hours24h: "HH",
  seconds: "ss",
  fullTime: "LT",
  fullTime12h: "hh:mm A",
  fullTime24h: "HH:mm",
  fullDate: "ll",
  fullDateWithWeekday: "dddd, LL",
  fullDateTime: "lll",
  fullDateTime12h: "ll hh:mm A",
  fullDateTime24h: "ll HH:mm",
  keyboardDate: "L",
  keyboardDateTime: "L LT",
  keyboardDateTime12h: "L hh:mm A",
  keyboardDateTime24h: "L HH:mm"
};
var DayjsUtils = class {
  constructor({ locale, formats, instance } = {}) {
    this.lib = "dayjs";
    this.is12HourCycleInCurrentLocale = () => {
      var _a, _b, _c;
      return /A|a/.test((_c = (_b = (_a = this.rawDayJsInstance.Ls[this.locale || "en"]) === null || _a === void 0 ? void 0 : _a.formats) === null || _b === void 0 ? void 0 : _b.LT) !== null && _c !== void 0 ? _c : "");
    };
    this.getCurrentLocaleCode = () => {
      return this.locale || "en";
    };
    this.getFormatHelperText = (format) => {
      var _a, _b;
      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?)|./g;
      return (_b = (_a = format.match(localFormattingTokens)) === null || _a === void 0 ? void 0 : _a.map((token) => {
        var _a2, _b2;
        var firstCharacter = token[0];
        if (firstCharacter === "L") {
          return (_b2 = (_a2 = this.rawDayJsInstance.Ls[this.locale || "en"]) === null || _a2 === void 0 ? void 0 : _a2.formats[token]) !== null && _b2 !== void 0 ? _b2 : token;
        }
        return token;
      }).join("").replace(/a/gi, "(a|p)m").toLocaleLowerCase()) !== null && _b !== void 0 ? _b : format;
    };
    this.parseISO = (isoString) => {
      return this.dayjs(isoString);
    };
    this.toISO = (value) => {
      return value.toISOString();
    };
    this.parse = (value, format) => {
      if (value === "") {
        return null;
      }
      return this.dayjs(value, format, this.locale, true);
    };
    this.date = (value) => {
      if (value === null) {
        return null;
      }
      return this.dayjs(value);
    };
    this.toJsDate = (value) => {
      return value.toDate();
    };
    this.isValid = (value) => {
      return this.dayjs(value).isValid();
    };
    this.isNull = (date) => {
      return date === null;
    };
    this.getDiff = (date, comparing, units) => {
      if (typeof comparing === "string") {
        comparing = this.dayjs(comparing);
      }
      if (!comparing.isValid()) {
        return 0;
      }
      return date.diff(comparing, units);
    };
    this.isAfter = (date, value) => {
      return date.isAfter(value);
    };
    this.isBefore = (date, value) => {
      return date.isBefore(value);
    };
    this.isAfterDay = (date, value) => {
      return date.isAfter(value, "day");
    };
    this.isBeforeDay = (date, value) => {
      return date.isBefore(value, "day");
    };
    this.isAfterMonth = (date, value) => {
      return date.isAfter(value, "month");
    };
    this.isBeforeMonth = (date, value) => {
      return date.isBefore(value, "month");
    };
    this.isBeforeYear = (date, value) => {
      return date.isBefore(value, "year");
    };
    this.isAfterYear = (date, value) => {
      return date.isAfter(value, "year");
    };
    this.startOfDay = (date) => {
      return date.startOf("day");
    };
    this.endOfDay = (date) => {
      return date.endOf("day");
    };
    this.format = (date, formatKey) => {
      return this.formatByString(date, this.formats[formatKey]);
    };
    this.formatByString = (date, formatString) => {
      return this.dayjs(date).format(formatString);
    };
    this.formatNumber = (numberToFormat) => {
      return numberToFormat;
    };
    this.getHours = (date) => {
      return date.hour();
    };
    this.addSeconds = (date, count) => {
      return count < 0 ? date.subtract(Math.abs(count), "second") : date.add(count, "second");
    };
    this.addMinutes = (date, count) => {
      return count < 0 ? date.subtract(Math.abs(count), "minute") : date.add(count, "minute");
    };
    this.addHours = (date, count) => {
      return count < 0 ? date.subtract(Math.abs(count), "hour") : date.add(count, "hour");
    };
    this.addDays = (date, count) => {
      return count < 0 ? date.subtract(Math.abs(count), "day") : date.add(count, "day");
    };
    this.addWeeks = (date, count) => {
      return count < 0 ? date.subtract(Math.abs(count), "week") : date.add(count, "week");
    };
    this.addMonths = (date, count) => {
      return count < 0 ? date.subtract(Math.abs(count), "month") : date.add(count, "month");
    };
    this.addYears = (date, count) => {
      return count < 0 ? date.subtract(Math.abs(count), "year") : date.add(count, "year");
    };
    this.setMonth = (date, count) => {
      return date.set("month", count);
    };
    this.setHours = (date, count) => {
      return date.set("hour", count);
    };
    this.getMinutes = (date) => {
      return date.minute();
    };
    this.setMinutes = (date, count) => {
      return date.set("minute", count);
    };
    this.getSeconds = (date) => {
      return date.second();
    };
    this.setSeconds = (date, count) => {
      return date.set("second", count);
    };
    this.getMonth = (date) => {
      return date.month();
    };
    this.getDate = (date) => {
      return date.date();
    };
    this.setDate = (date, count) => {
      return date.set("date", count);
    };
    this.getDaysInMonth = (date) => {
      return date.daysInMonth();
    };
    this.isSameDay = (date, comparing) => {
      return date.isSame(comparing, "day");
    };
    this.isSameMonth = (date, comparing) => {
      return date.isSame(comparing, "month");
    };
    this.isSameYear = (date, comparing) => {
      return date.isSame(comparing, "year");
    };
    this.isSameHour = (date, comparing) => {
      return date.isSame(comparing, "hour");
    };
    this.getMeridiemText = (ampm) => {
      return ampm === "am" ? "AM" : "PM";
    };
    this.startOfYear = (date) => {
      return date.startOf("year");
    };
    this.endOfYear = (date) => {
      return date.endOf("year");
    };
    this.startOfMonth = (date) => {
      return date.startOf("month");
    };
    this.endOfMonth = (date) => {
      return date.endOf("month");
    };
    this.startOfWeek = (date) => {
      return date.startOf("week");
    };
    this.endOfWeek = (date) => {
      return date.endOf("week");
    };
    this.getNextMonth = (date) => {
      return date.add(1, "month");
    };
    this.getPreviousMonth = (date) => {
      return date.subtract(1, "month");
    };
    this.getMonthArray = (date) => {
      const firstMonth = date.startOf("year");
      const monthArray = [firstMonth];
      while (monthArray.length < 12) {
        const prevMonth = monthArray[monthArray.length - 1];
        monthArray.push(this.getNextMonth(prevMonth));
      }
      return monthArray;
    };
    this.getYear = (date) => {
      return date.year();
    };
    this.setYear = (date, year) => {
      return date.set("year", year);
    };
    this.mergeDateAndTime = (date, time) => {
      return date.hour(time.hour()).minute(time.minute()).second(time.second());
    };
    this.getWeekdays = () => {
      const start = this.dayjs().startOf("week");
      return [0, 1, 2, 3, 4, 5, 6].map((diff) => this.formatByString(start.add(diff, "day"), "dd"));
    };
    this.isEqual = (value, comparing) => {
      if (value === null && comparing === null) {
        return true;
      }
      return this.dayjs(value).isSame(comparing);
    };
    this.getWeekArray = (date) => {
      const start = this.dayjs(date).startOf("month").startOf("week");
      const end = this.dayjs(date).endOf("month").endOf("week");
      let count = 0;
      let current = start;
      const nestedWeeks = [];
      while (current.isBefore(end)) {
        const weekNumber = Math.floor(count / 7);
        nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
        nestedWeeks[weekNumber].push(current);
        current = current.add(1, "day");
        count += 1;
      }
      return nestedWeeks;
    };
    this.getYearRange = (start, end) => {
      const startDate = this.dayjs(start).startOf("year");
      const endDate = this.dayjs(end).endOf("year");
      const years = [];
      let current = startDate;
      while (current.isBefore(endDate)) {
        years.push(current);
        current = current.add(1, "year");
      }
      return years;
    };
    this.isWithinRange = (date, [start, end]) => {
      return date.isBetween(start, end, null, "[]");
    };
    this.rawDayJsInstance = instance || import_dayjs.default;
    this.dayjs = withLocale(this.rawDayJsInstance, locale);
    this.locale = locale;
    this.formats = Object.assign({}, defaultFormats, formats);
  }
};

// node_modules/@mui/x-date-pickers/AdapterDayjs/index.js
var formatTokenMap = {
  YY: "year",
  YYYY: "year",
  M: "month",
  MM: "month",
  MMM: "month",
  MMMM: "month",
  D: "day",
  DD: "day",
  H: "hour",
  HH: "hour",
  h: "hour",
  hh: "hour",
  m: "minute",
  mm: "minute",
  s: "second",
  ss: "second",
  A: "am-pm",
  a: "am-pm"
};
var AdapterDayjs = class extends DayjsUtils {
  constructor(...args) {
    super(...args);
    this.formatTokenMap = formatTokenMap;
    this.expandFormat = (format) => {
      var _this$rawDayJsInstanc;
      const localeFormats = (_this$rawDayJsInstanc = this.rawDayJsInstance.Ls[this.locale || "en"]) == null ? void 0 : _this$rawDayJsInstanc.formats;
      const t = (formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_, a, b) => a || b.slice(1));
      return format.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_, a, b) => {
        const B = b && b.toUpperCase();
        return a || localeFormats[b] || t(localeFormats[B]);
      });
    };
    this.getFormatHelperText = (format) => {
      return this.expandFormat(format).replace(/a/gi, "(a|p)m").toLocaleLowerCase();
    };
  }
};
export {
  AdapterDayjs
};
//# sourceMappingURL=@mui_x-date-pickers_AdapterDayjs.js.map
